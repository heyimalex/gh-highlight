{
  "name": "Babel ES6 JavaScript",
  "scopeName": "source.js.jsx",
  "patterns": [
    {
      "include": "#core"
    }
  ],
  "repository": {
    "brackets": {
      "patterns": [
        {
          "include": "#round-brackets"
        },
        {
          "include": "#square-brackets"
        },
        {
          "include": "#curly-brackets"
        }
      ]
    },
    "class-body": {
      "patterns": [
        {
          "include": "#flowtype-keywords"
        },
        {
          "include": "#literal-method"
        },
        {
          "include": "#brackets"
        },
        {
          "include": "#es7-decorators"
        },
        {
          "include": "#comments"
        },
        {
          "begin": "\\s*+(?==[^=\u003e])",
          "patterns": [
            {
              "include": "#expression"
            }
          ],
          "endCaptures": {
            "4": {
              "name": "punctuation.terminator.statement.js"
            }
          }
        },
        {
          "name": "storage.modifier.js",
          "match": "\\s*+\\b(?\u003c!\\.)static\\b(?!\\.)"
        },
        {
          "include": "#flowtype-variable"
        },
        {
          "include": "#literal-semi-colon"
        }
      ]
    },
    "comments": {
      "patterns": [
        {
          "include": "#special-comments-conditional-compilation"
        },
        {
          "name": "comment.block.documentation.js",
          "begin": "\\s*+/\\*\\*(?!/)",
          "end": "\\s*\\*/",
          "patterns": [
            {
              "include": "#jsdoc"
            }
          ],
          "captures": {
            "0": {
              "name": "punctuation.definition.comment.js"
            }
          }
        },
        {
          "name": "comment.block.js",
          "begin": "\\s*+/\\*",
          "end": "\\s*\\*/",
          "captures": {
            "0": {
              "name": "punctuation.definition.comment.js"
            }
          }
        },
        {
          "name": "comment.block.html.js",
          "match": "\\s*+(\u003c!--|--\u003e)",
          "captures": {
            "0": {
              "name": "punctuation.definition.comment.js"
            }
          }
        },
        {
          "name": "comment.line.double-slash.js",
          "begin": "\\s*+(//)",
          "end": "\\s*$",
          "beginCaptures": {
            "1": {
              "name": "punctuation.definition.comment.js"
            }
          }
        },
        {
          "name": "comment.line.shebang.js",
          "match": "^(#!).*$\\n?",
          "captures": {
            "1": {
              "name": "punctuation.definition.comment.js"
            }
          }
        }
      ]
    },
    "core": {
      "patterns": [
        {
          "include": "#ignore-long-lines"
        },
        {
          "include": "#flowtype-keywords"
        },
        {
          "include": "#literal-function-labels"
        },
        {
          "include": "#literal-arrow-function-labels"
        },
        {
          "include": "#literal-labels"
        },
        {
          "include": "#literal-for"
        },
        {
          "include": "#literal-switch"
        },
        {
          "include": "#expression"
        },
        {
          "include": "#literal-keywords"
        },
        {
          "include": "#literal-punctuation"
        }
      ]
    },
    "curly-brackets": {
      "patterns": [
        {
          "begin": "\\s*+\\{",
          "end": "\\s*\\}",
          "patterns": [
            {
              "include": "$self"
            }
          ],
          "beginCaptures": {
            "0": {
              "name": "meta.brace.curly.js"
            }
          },
          "endCaptures": {
            "0": {
              "name": "meta.brace.curly.js"
            }
          }
        }
      ]
    },
    "es7-decorators": {
      "patterns": [
        {
          "name": "tag.decorator.js",
          "match": "\\s*+(?\u003c!@)(@)([_$a-zA-Z][$\\w]*)\\b",
          "captures": {
            "1": {
              "name": "punctuation.definition.tag.js"
            },
            "2": {
              "name": "entity.name.tag.js"
            }
          }
        }
      ]
    },
    "expression": {
      "patterns": [
        {
          "include": "#ignore-long-lines"
        },
        {
          "include": "#jsx"
        },
        {
          "include": "#es7-decorators"
        },
        {
          "include": "#support"
        },
        {
          "include": "#literal-function-labels"
        },
        {
          "include": "#literal-arrow-function-labels"
        },
        {
          "include": "#literal-function"
        },
        {
          "include": "#literal-arrow-function"
        },
        {
          "include": "#literal-method-alternate"
        },
        {
          "include": "#literal-prototype"
        },
        {
          "include": "#literal-regexp"
        },
        {
          "include": "#literal-number"
        },
        {
          "include": "#literal-quasi"
        },
        {
          "include": "#literal-string"
        },
        {
          "include": "#literal-language-constant"
        },
        {
          "include": "#literal-language-variable"
        },
        {
          "include": "#literal-object"
        },
        {
          "include": "#literal-module"
        },
        {
          "include": "#literal-class"
        },
        {
          "include": "#literal-constructor"
        },
        {
          "include": "#literal-method-call"
        },
        {
          "include": "#literal-function-call"
        },
        {
          "include": "#comments"
        },
        {
          "include": "#brackets"
        },
        {
          "include": "#literal-operators"
        },
        {
          "include": "#literal-variable"
        },
        {
          "include": "#literal-comma"
        },
        {
          "include": "#miscellaneous"
        }
      ]
    },
    "flowtype": {
      "patterns": [
        {
          "include": "#comments"
        },
        {
          "include": "#flowtype-polymorphs"
        },
        {
          "include": "#flowtype-bracketed-parameters"
        },
        {
          "include": "#flowtype-return"
        }
      ]
    },
    "flowtype-bracketed-parameters": {
      "patterns": [
        {
          "begin": "(?\u003c!=)\\s*+(\\()",
          "end": "\\s*(\\))",
          "patterns": [
            {
              "include": "#flowtype-variable"
            }
          ],
          "beginCaptures": {
            "1": {
              "name": "punctuation.definition.parameters.begin.js"
            }
          },
          "endCaptures": {
            "1": {
              "name": "punctuation.definition.parameters.end.js"
            }
          }
        }
      ]
    },
    "flowtype-declare": {
      "patterns": [
        {
          "match": "\\s*+(?\u003c!\\.)\\b(declare)\\b\\s++(?=\\b(function|var|type|interface)\\s++)",
          "captures": {
            "1": {
              "name": "keyword.other.declare.flowtype"
            }
          }
        },
        {
          "begin": "\\s*+(?\u003c!\\.)\\b(declare)\\b\\s*+\\b(module)(.)(exports)(:)",
          "end": "(?=.)",
          "patterns": [
            {
              "include": "#flowtype-parse-types"
            }
          ],
          "beginCaptures": {
            "1": {
              "name": "keyword.other.declare.flowtype"
            },
            "2": {
              "name": "storage.type.module.flowtype"
            },
            "3": {
              "name": "keyword.operator.accessor.flowtype"
            },
            "4": {
              "name": "storage.type.module.flowtype"
            },
            "5": {
              "name": "punctuation.type.flowtype"
            }
          },
          "applyEndPatternLast": true
        },
        {
          "begin": "\\s*+(?\u003c!\\.)\\b(declare)\\b\\s*+\\b(module)\\b",
          "end": "\\s*(?\u003c=})",
          "patterns": [
            {
              "include": "#flowtype-polymorphs"
            },
            {
              "name": "entity.name.class.js",
              "match": "(?\u003c!\\.)\\s*+([$_\\p{L}](?:[$\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}])*+)"
            },
            {
              "include": "#literal-string"
            },
            {
              "contentName": "meta.class.body.js",
              "begin": "\\s*+({)",
              "end": "\\s*(})",
              "patterns": [
                {
                  "include": "#flowtype-literal-method"
                },
                {
                  "include": "#class-body"
                }
              ],
              "beginCaptures": {
                "1": {
                  "name": "punctuation.section.class.begin.js"
                }
              },
              "endCaptures": {
                "1": {
                  "name": "punctuation.section.class.end.js"
                }
              }
            }
          ],
          "beginCaptures": {
            "1": {
              "name": "keyword.other.declare.flowtype"
            },
            "2": {
              "name": "storage.type.module.flowtype"
            }
          }
        },
        {
          "begin": "\\s*+(?\u003c!\\.)\\b(declare)\\b\\s*+\\b(class)\\b",
          "end": "\\s*(?\u003c=})",
          "patterns": [
            {
              "include": "#flowtype-polymorphs"
            },
            {
              "match": "\\s*+\\b((extends))\\b\\s*+",
              "captures": {
                "1": {
                  "name": "meta.class.extends.js"
                },
                "2": {
                  "name": "storage.type.extends.js"
                }
              }
            },
            {
              "begin": "\\s*+\\b((mixins))\\b\\s*+",
              "end": "\\s*(?={)",
              "patterns": [
                {
                  "name": "entity.name.class.js",
                  "match": "(?\u003c!\\.)\\s*+([$_\\p{L}](?:[$\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}])*+)"
                },
                {
                  "include": "#literal-coma"
                }
              ],
              "beginCaptures": {
                "1": {
                  "name": "meta.class.extends.js"
                },
                "2": {
                  "name": "storage.type.extends.js"
                }
              }
            },
            {
              "name": "entity.name.class.js",
              "match": "(?\u003c!\\.)\\s*+([$_\\p{L}](?:[$\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}])*+)"
            },
            {
              "contentName": "meta.class.body.js",
              "begin": "\\s*+({)",
              "end": "\\s*(})",
              "patterns": [
                {
                  "include": "#flowtype-literal-method"
                },
                {
                  "include": "#class-body"
                }
              ],
              "beginCaptures": {
                "1": {
                  "name": "punctuation.section.class.begin.js"
                }
              },
              "endCaptures": {
                "1": {
                  "name": "punctuation.section.class.end.js"
                }
              }
            }
          ],
          "beginCaptures": {
            "1": {
              "name": "keyword.other.declare.flowtype"
            },
            "2": {
              "name": "storage.type.class.flowtype"
            }
          }
        }
      ]
    },
    "flowtype-interface": {
      "begin": "\\s*+(?\u003c!\\.)\\b(interface)\\s++",
      "end": "\\s*(?\u003c=})",
      "patterns": [
        {
          "name": "support.type.class.interface.js",
          "match": "(?\u003c!\\.)\\s*+([$_\\p{L}](?:[$\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}])*+)"
        },
        {
          "include": "#flowtype-polymorphs"
        },
        {
          "contentName": "meta.class.body.js",
          "begin": "\\s*+{",
          "end": "\\s*(})",
          "patterns": [
            {
              "include": "#flowtype-literal-method"
            },
            {
              "include": "#class-body"
            }
          ],
          "beginCaptures": {
            "0": {
              "name": "punctuation.section.class.begin.js"
            }
          },
          "endCaptures": {
            "1": {
              "name": "punctuation.section.class.end.js"
            }
          }
        }
      ],
      "beginCaptures": {
        "1": {
          "name": "keyword.other.interface.flowtype"
        }
      }
    },
    "flowtype-keywords": {
      "patterns": [
        {
          "include": "#flowtype-declare"
        },
        {
          "include": "#flowtype-type-aliases"
        },
        {
          "include": "#flowtype-interface"
        }
      ]
    },
    "flowtype-literal-method": {
      "begin": "(?\u003c!:)\\s*+(?=(\u003c(?:(?\u003e[^\u003c\u003e]+)|\\g\u003c-1\u003e)*\u003e)?(\\())",
      "end": "\\s*(?=.)",
      "patterns": [
        {
          "include": "#flowtype"
        }
      ],
      "beginCaptures": {
        "1": {
          "name": "storage.modifier.js"
        },
        "2": {
          "name": "storage.type.js"
        },
        "3": {
          "name": "keyword.generator.asterisk.js"
        }
      },
      "applyEndPatternLast": true
    },
    "flowtype-object-property": {
      "patterns": [
        {
          "captures": {
            "1": {
              "name": "variable.other.property.flowtype"
            },
            "5": {
              "name": "keyword.operator.optional.parameter.flowtype"
            }
          }
        },
        {
          "include": "#flowtype-vars-and-props"
        }
      ]
    },
    "flowtype-parse-array": {
      "begin": "(?\u003c!=|[$_A-Za-z0-9])\\s*+(\\[)",
      "end": "\\s*(\\])",
      "patterns": [
        {
          "include": "#flowtype-variable"
        }
      ],
      "beginCaptures": {
        "1": {
          "name": "meta.brace.square.open.flowtype"
        }
      },
      "endCaptures": {
        "1": {
          "name": "meta.brace.square.end.flowtype"
        }
      }
    },
    "flowtype-parse-objects": {
      "begin": "(?\u003c=:|\\||\u0026|\\?|=\u003e|\u003c)\\s*+(\\{)",
      "end": "\\s*(\\})",
      "patterns": [
        {
          "include": "#flowtype-object-property"
        }
      ],
      "beginCaptures": {
        "1": {
          "name": "meta.brace.round.open.flowtype"
        }
      },
      "endCaptures": {
        "1": {
          "name": "meta.brace.round.close.flowtype"
        }
      },
      "applyEndPatternLast": true
    },
    "flowtype-parse-types": {
      "patterns": [
        {
          "name": "keyword.operator.maybe.flowtype",
          "match": "\\s*+\\?"
        },
        {
          "name": "keyword.operator.flowtype",
          "match": "\\s*+\\btypeof\\b\\s*+"
        },
        {
          "match": "(?!^)\\s*+\\b((?\u003eany|boolean|mixed|number|string|void))\\b",
          "captures": {
            "1": {
              "name": "support.type.builtin.primitive.flowtype"
            }
          }
        },
        {
          "match": "(?!^)\\s*+\\b((?\u003eArrayBuffer|ArrayBufferView|Boolean|Date|DataView|Error|EvalError|Float32Array|Float64Array|Function|Int8Array|Int16Array|Int32Array|JSON|Math|Number|Object|RangeError|ReferenceError|RegExp|String|Symbol|TypeError|Uint8Array|Uint16Array|Uint32Array|Uint8ClampedArray))\\b",
          "captures": {
            "1": {
              "name": "support.type.builtin.class.flowtype"
            }
          }
        },
        {
          "include": "#flowtype-polymorphs"
        },
        {
          "match": "(?!^)\\s*+([$_[\\p{Lu}\\p{Lt}\\p{Lm}\\p{Lo}]][$.\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}]*+)(?!\\s*+\\()",
          "captures": {
            "1": {
              "name": "support.type.class.flowtype"
            }
          }
        },
        {
          "match": "(?!^)\\s*+(?!\\b(if|switch|try|var|let|const|static|function|return|class|do|for|while|debugger|export|import|yield|type|declare|interface)\\b)([$_\\p{L}][$.\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}]*+)(?!\\s*+\\()",
          "captures": {
            "2": {
              "name": "support.type.primitive.flowtype"
            }
          }
        },
        {
          "name": "kewyword.operator.union.flowtype",
          "match": "\\s*+\\|"
        },
        {
          "name": "kewyword.operator.intersection.flowtype",
          "match": "\\s*+\\\u0026"
        },
        {
          "name": "kewyword.operator.existential.flowtype",
          "match": "\\s*+\\*"
        },
        {
          "name": "punctuation.type.flowtype",
          "match": "\\s*+(:)"
        },
        {
          "match": "(?\u003c=\\))\\s*+(=\u003e)",
          "captures": {
            "1": {
              "name": "storage.type.function.arrow.js"
            }
          }
        },
        {
          "include": "#literal-string"
        },
        {
          "include": "#literal-number"
        },
        {
          "include": "#flowtype-bracketed-parameters"
        },
        {
          "include": "#flowtype-parse-objects"
        },
        {
          "include": "#flowtype-parse-array"
        },
        {
          "include": "#comments"
        }
      ]
    },
    "flowtype-polymorphs": {
      "patterns": [
        {
          "begin": "\\s*+\\b((?\u003eArray|Class|Map|Promise|Set|WeakMap|WeakSet))\\s*+(\u003c)",
          "end": "\\s*(\u003e)",
          "patterns": [
            {
              "include": "#literal-comma"
            },
            {
              "match": "\\s*+(\\+|-)",
              "captures": {
                "1": {
                  "name": "support.type.variant.flowtype"
                }
              }
            },
            {
              "include": "#flowtype-parse-types"
            }
          ],
          "beginCaptures": {
            "1": {
              "name": "support.type.builtin.class.flowtype"
            },
            "2": {
              "name": "punctuation.flowtype"
            }
          },
          "endCaptures": {
            "1": {
              "name": "punctuation.flowtype"
            }
          }
        },
        {
          "begin": "\\s*+(\u003c)(?!\u003c)",
          "end": "\\s*(\u003e)",
          "patterns": [
            {
              "include": "#literal-comma"
            },
            {
              "match": "\\s*+(\\+|-)",
              "captures": {
                "1": {
                  "name": "support.type.variant.flowtype"
                }
              }
            },
            {
              "include": "#flowtype-parse-types"
            }
          ],
          "beginCaptures": {
            "1": {
              "name": "punctutation.flowtype"
            }
          },
          "endCaptures": {
            "1": {
              "name": "punctutation.flowtype"
            }
          }
        }
      ]
    },
    "flowtype-return": {
      "patterns": [
        {
          "begin": "(?\u003c=\\))\\s*+(:)",
          "end": "(?=.)",
          "patterns": [
            {
              "include": "#flowtype-parse-types"
            }
          ],
          "beginCaptures": {
            "1": {
              "name": "punctuation.type.flowtype"
            }
          },
          "applyEndPatternLast": true
        }
      ]
    },
    "flowtype-type-aliases": {
      "patterns": [
        {
          "begin": "\\s*+(?:\\b(import|export))?\\b\\s*(type)\\b\\s*(?!(instanceof|in)\\b)(?=[$_A-Za-z{\\[])",
          "end": "\\s*(\\;)|\\b(?=if|switch|try|var|let|const|static|function|return|class|do|for|while|debugger|export|import|yield|type|declare|interface)\\b",
          "patterns": [
            {
              "match": "\\s*+="
            },
            {
              "begin": "\\s*+{",
              "end": "\\s*}",
              "patterns": [
                {
                  "include": "#flowtype"
                },
                {
                  "include": "#flowtype-variable"
                },
                {
                  "include": "#comments"
                },
                {
                  "include": "#flowtype-function-name"
                }
              ],
              "beginCaptures": {
                "0": {
                  "name": "meta.brace.curly.js"
                }
              },
              "endCaptures": {
                "0": {
                  "name": "meta.brace.curly.js"
                }
              },
              "applyEndPatternLast": true
            },
            {
              "include": "#flowtype"
            },
            {
              "include": "#flowtype-parse-types"
            },
            {
              "include": "#comments"
            },
            {
              "include": "#flowtype-function-name"
            }
          ],
          "beginCaptures": {
            "1": {
              "name": "keyword.control.module.js"
            },
            "2": {
              "name": "keyword.other.typedef.flowtype"
            }
          },
          "endCaptures": {
            "1": {
              "name": "punctuation.object.end.flowtype"
            }
          }
        }
      ]
    },
    "flowtype-typecast": {
      "patterns": [
        {
          "begin": "\\s*+:",
          "end": "(?=\\s*+\\))",
          "patterns": [
            {
              "include": "#flowtype-parse-types"
            }
          ]
        }
      ]
    },
    "flowtype-variable": {
      "patterns": [
        {
          "match": "(?\u003c!\\.)\\s*+([$_\\p{L}](?:[$.\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}])*+)\\s*+(\\??)\\s*+(?=:\\s*(\\bFunction\\b|(\\((?:(?\u003e[^()]+)|\\g\u003c-1\u003e)*\\))\\s*=\u003e|\\(\\s*$))",
          "captures": {
            "1": {
              "name": "storage.type.function.js"
            },
            "2": {
              "name": "keyword.operator.optional.parameter.flowtype"
            }
          }
        },
        {
          "match": "\\s*+((?\u003c!\\.)\\.\\.\\.)?([$_\\p{L}](?:[$.\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}])*+)\\s*+(\\??)\\s*+(?=:|=\u003e)",
          "captures": {
            "1": {
              "name": "keyword.operator.spread.js"
            },
            "2": {
              "name": "variable.other.readwrite.js"
            },
            "3": {
              "name": "keyword.operator.optional.parameter.flowtype"
            }
          }
        },
        {
          "include": "#flowtype-vars-and-props"
        }
      ]
    },
    "flowtype-vars-and-props": {
      "patterns": [
        {
          "name": "punctuation.type.flowtype",
          "match": "\\s*+\\?"
        },
        {
          "name": "kewyword.operator.union.flowtype",
          "match": "\\s*+\\|"
        },
        {
          "name": "kewyword.operator.intersection.flowtype",
          "match": "\\s*+\\\u0026"
        },
        {
          "begin": "\\s*+(:)",
          "end": "(?=.)",
          "patterns": [
            {
              "include": "#flowtype-parse-types"
            }
          ],
          "beginCaptures": {
            "1": {
              "name": "punctuation.type.flowtype"
            }
          },
          "applyEndPatternLast": true
        },
        {
          "include": "#literal-comma"
        },
        {
          "match": "\\s*+@@"
        },
        {
          "begin": "\\s*+(=\u003e)",
          "end": "(?=.)",
          "patterns": [
            {
              "include": "#flowtype-parse-types"
            }
          ],
          "beginCaptures": {
            "1": {
              "name": "storage.type.function.arrow.js"
            }
          },
          "applyEndPatternLast": true
        },
        {
          "begin": "\\s*+(?=([$_\\p{L}](?:[$.\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}])*+)?\\s*=)(?!=\u003e|==)",
          "end": "\\s*(?=,|;|\\)|}|\\]|\\b(if|switch|try|var|let|const|static|function|return|class|do|for|while|debugger|export|import|yield)\\b|type\\s+[$\\w]+|declare\\s+[$\\w]+|interface\\s+[$\\w]+)",
          "patterns": [
            {
              "include": "#expression"
            }
          ]
        },
        {
          "include": "#flowtype-bracketed-parameters"
        },
        {
          "include": "#flowtype-parse-array"
        },
        {
          "include": "#expression"
        }
      ]
    },
    "ignore-long-lines": {
      "patterns": [
        {
          "match": "^(?:).{1000,}"
        }
      ]
    },
    "jsdoc": {
      "patterns": [
        {
          "name": "storage.type.class.doc",
          "match": "(?\u003c!\\w)@(abstract|alias|author|class|constructor|deprecated|enum|event|example|extends|fires|ignore|inheritdoc|member|method|param|private|property|protected|readonly|requires|return|since|static|throws|type|var)\\b"
        },
        {
          "name": "storage.type.class.jsdoc",
          "match": "(?\u003c!\\w)@(access|also|arg|arguments|augments|borrows|borrowsThis|callback|callbackDocument|classdesc|constant|const|constructs|copyright|default|defaultvalue|desc|description|emits|exception|exports|external|file|fileoverview|function|func|global|host|implements|inner|instance|interface|kind|lends|license|listens|link|linkcode|linkplain|memberof|mixes|mixin|module|name|namespace|overview|prop|public|returns|see|summary|this|todo|tutorial|typedef|undocumented|variation|version|virtual)\\b"
        },
        {
          "name": "storage.type.class.jsduck",
          "match": "(?\u003c!\\w)@(accessor|alternateClassName|aside|cfg|chainable|docauthor|evented|experimental|ftype|hide|inheritable|localdoc|markdown|mixins|new|override|preventable|ptype|removed|scss mixin|singleton|template|uses|xtype)\\b"
        }
      ]
    },
    "jsx": {
      "patterns": [
        {
          "begin": "(?\u003c=\\(|\\{|\\[|,|\u0026\u0026|\\|\\||\\?|:|=|=\u003e|\\Wreturn|^return|\\Wdefault|^)\\s*+(?=\u003c[$_\\p{L}])",
          "end": "(?=.)",
          "patterns": [
            {
              "include": "#jsx-tag-element-name"
            }
          ],
          "applyEndPatternLast": true
        }
      ]
    },
    "jsx-assignment": {
      "patterns": [
        {
          "name": "keyword.operator.assignment.jsx",
          "match": "=(?=\\s*(?:'|\"|{|/\\*|\u003c|//|\\n))"
        }
      ]
    },
    "jsx-attribute-name": {
      "patterns": [
        {
          "match": "(?\u003c!\\S)([$_\\p{L}](?:[$.\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}-](?\u003c!\\.\\.))*+)(?\u003c!\\.)(?=//|/\\*|=|\\s|\u003e|/\u003e)",
          "captures": {
            "0": {
              "name": "entity.other.attribute-name.jsx"
            }
          }
        }
      ]
    },
    "jsx-entities": {
      "patterns": [
        {
          "match": "(\u0026)([a-zA-Z0-9]+|#[0-9]+|#x[0-9a-fA-F]+)(;)",
          "captures": {
            "0": {
              "name": "constant.character.entity.jsx"
            },
            "1": {
              "name": "punctuation.definition.entity.jsx"
            },
            "2": {
              "name": "entity.name.tag.html.jsx"
            },
            "3": {
              "name": "punctuation.definition.entity.jsx"
            }
          }
        },
        {
          "name": "invalid.illegal.bad-ampersand.jsx",
          "match": "\u0026\\s*+;"
        }
      ]
    },
    "jsx-evaluated-code": {
      "name": "meta.embedded.expression.js",
      "contentName": "source.js.jsx",
      "begin": "{",
      "end": "}",
      "patterns": [
        {
          "include": "#jsx-string-double-quoted"
        },
        {
          "include": "#jsx-string-single-quoted"
        },
        {
          "include": "#jsx-spread-attribute"
        },
        {
          "include": "#expression"
        }
      ],
      "beginCaptures": {
        "0": {
          "name": "punctuation.section.embedded.begin.jsx"
        }
      },
      "endCaptures": {
        "0": {
          "name": "punctuation.section.embedded.end.jsx"
        }
      }
    },
    "jsx-spread-attribute": {
      "patterns": [
        {
          "name": "keyword.operator.spread.jsx",
          "match": "(?\u003c!\\.)\\.\\.\\."
        }
      ]
    },
    "jsx-string-double-quoted": {
      "name": "string.quoted.double.js",
      "begin": "\"",
      "end": "\"(?\u003c!\\\\\")",
      "patterns": [
        {
          "include": "#jsx-entities"
        }
      ],
      "beginCaptures": {
        "0": {
          "name": "punctuation.definition.string.begin.jsx"
        }
      },
      "endCaptures": {
        "0": {
          "name": "punctuation.definition.string.end.jsx"
        }
      }
    },
    "jsx-string-single-quoted": {
      "name": "string.quoted.single.js",
      "begin": "'",
      "end": "'(?\u003c!\\\\')",
      "patterns": [
        {
          "include": "#jsx-entities"
        }
      ],
      "beginCaptures": {
        "0": {
          "name": "punctuation.definition.string.begin.jsx"
        }
      },
      "endCaptures": {
        "0": {
          "name": "punctuation.definition.string.end.jsx"
        }
      }
    },
    "jsx-tag-attributes": {
      "patterns": [
        {
          "include": "#jsx-attribute-name"
        },
        {
          "include": "#jsx-assignment"
        },
        {
          "include": "#jsx-string-double-quoted"
        },
        {
          "include": "#jsx-string-single-quoted"
        },
        {
          "include": "#jsx-evaluated-code"
        },
        {
          "include": "#jsx-tag-element-name"
        },
        {
          "include": "#comments"
        }
      ]
    },
    "jsx-tag-element-name": {
      "patterns": [
        {
          "name": "meta.tag.jsx",
          "begin": "\\s*+(\u003c)((\\p{Ll}[\\p{Ll}0-9]*)|((?:[$_\\p{L}\\p{Nl}][$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}-]*?:)?+(?:[$_\\p{L}\\p{Nl}](?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\.-](?\u003c!\\.\\.))*+)+))(?=[ /\u003e\\s])(?![:])(?\u003c!\\.|:)",
          "end": "\\s*(?\u003c=\u003c/)((\\4)|\\2)(\u003e)|(/\u003e)|((?\u003c=\u003c/)[\\S ]*?)\u003e",
          "patterns": [
            {
              "include": "#jsx-tag-termination"
            },
            {
              "include": "#jsx-tag-attributes"
            }
          ],
          "beginCaptures": {
            "1": {
              "name": "punctuation.definition.tag.jsx"
            },
            "2": {
              "name": "entity.name.tag.open.jsx"
            },
            "4": {
              "name": "support.class.component.open.jsx"
            }
          },
          "endCaptures": {
            "1": {
              "name": "entity.name.tag.close.jsx"
            },
            "2": {
              "name": "support.class.component.close.jsx"
            },
            "3": {
              "name": "punctuation.definition.tag.jsx"
            },
            "4": {
              "name": "punctuation.definition.tag.jsx"
            },
            "5": {
              "name": "invalid.illegal.termination.jsx"
            }
          }
        }
      ]
    },
    "jsx-tag-termination": {
      "patterns": [
        {
          "begin": "(\u003e)",
          "end": "(\u003c/)",
          "patterns": [
            {
              "include": "#jsx-evaluated-code"
            },
            {
              "include": "#jsx-entities"
            },
            {
              "include": "#jsx-tag-element-name"
            }
          ],
          "beginCaptures": {
            "0": {
              "name": "punctuation.definition.tag.jsx"
            },
            "1": {
              "name": "JSXStartTagEnd"
            }
          },
          "endCaptures": {
            "0": {
              "name": "punctuation.definition.tag.jsx"
            },
            "1": {
              "name": "JSXEndTagStart"
            }
          }
        }
      ]
    },
    "literal-arrow-function": {
      "patterns": [
        {
          "name": "meta.function.arrow.js",
          "end": "\\s*(=\u003e)",
          "patterns": [
            {
              "include": "#flowtype"
            }
          ],
          "beginCaptures": {
            "1": {
              "name": "storage.type.js"
            }
          },
          "endCaptures": {
            "1": {
              "name": "storage.type.function.arrow.js"
            }
          },
          "applyEndPatternLast": true
        },
        {
          "name": "meta.function.arrow.js",
          "match": "\\s*+(\\basync\\b)?\\s*+([_$a-zA-Z][$\\w]*)\\s*(=\u003e)",
          "captures": {
            "1": {
              "name": "storage.type.js"
            },
            "2": {
              "name": "variable.other.readwrite.js"
            },
            "3": {
              "name": "storage.type.function.arrow.js"
            }
          }
        },
        {
          "name": "meta.function.arrow.js",
          "end": "\\s*(=\u003e)",
          "patterns": [
            {
              "include": "#flowtype"
            }
          ],
          "beginCaptures": {
            "1": {
              "name": "entity.name.function.js"
            },
            "2": {
              "name": "keyword.operator.assignment.js"
            },
            "3": {
              "name": "storage.type.js"
            }
          },
          "endCaptures": {
            "1": {
              "name": "storage.type.function.arrow.js"
            }
          },
          "applyEndPatternLast": true
        },
        {
          "name": "meta.function.arrow.js",
          "match": "\\s*+(\\b[_$a-zA-Z][$\\w]*)\\s*+(=)\\s*+\\s*+(\\basync\\b)?\\s*+([_$a-zA-Z][$\\w]*)\\s*(=\u003e)",
          "captures": {
            "1": {
              "name": "entity.name.function.js"
            },
            "2": {
              "name": "keyword.operator.assignment.js"
            },
            "3": {
              "name": "storage.type.js"
            },
            "4": {
              "name": "variable.other.readwrite.js"
            },
            "5": {
              "name": "storage.type.function.arrow.js"
            }
          }
        },
        {
          "name": "meta.prototype.function.arrow.js",
          "end": "\\s*(=\u003e)",
          "patterns": [
            {
              "include": "#flowtype"
            }
          ],
          "beginCaptures": {
            "1": {
              "name": "entity.name.class.js"
            },
            "2": {
              "name": "keyword.operator.accessor.js"
            },
            "3": {
              "name": "variable.language.prototype.js"
            },
            "4": {
              "name": "keyword.operator.accessor.js"
            },
            "5": {
              "name": "entity.name.function.js"
            },
            "6": {
              "name": "keyword.operator.assignment.js"
            },
            "7": {
              "name": "storage.type.js"
            }
          },
          "endCaptures": {
            "1": {
              "name": "storage.type.function.arrow.js"
            }
          },
          "applyEndPatternLast": true
        },
        {
          "name": "meta.prototype.function.arrow.js",
          "match": "\\s*+(\\b_?[A-Z][$\\w]*)?(\\.)(prototype)(\\.)([_$a-zA-Z][$\\w]*)\\s*+(=)\\s*+(\\basync\\b)?\\s*+([_$a-zA-Z][$\\w]*)\\s*(=\u003e)",
          "captures": {
            "1": {
              "name": "entity.name.class.js"
            },
            "2": {
              "name": "keyword.operator.accessor.js"
            },
            "3": {
              "name": "variable.language.prototype.js"
            },
            "4": {
              "name": "keyword.operator.accessor.js"
            },
            "5": {
              "name": "entity.name.function.js"
            },
            "6": {
              "name": "keyword.operator.assignment.js"
            },
            "7": {
              "name": "storage.type.js"
            },
            "8": {
              "name": "variable.other.readwrite.js"
            },
            "9": {
              "name": "storage.type.function.arrow.js"
            }
          }
        },
        {
          "name": "meta.function.static.arrow.js",
          "end": "\\s*(=\u003e)",
          "patterns": [
            {
              "include": "#flowtype"
            }
          ],
          "beginCaptures": {
            "1": {
              "name": "entity.name.class.js"
            },
            "2": {
              "name": "keyword.operator.accessor.js"
            },
            "3": {
              "name": "entity.name.function.js"
            },
            "4": {
              "name": "keyword.operator.assignment.js"
            },
            "5": {
              "name": "storage.type.js"
            }
          },
          "endCaptures": {
            "1": {
              "name": "storage.type.function.arrow.js"
            }
          },
          "applyEndPatternLast": true
        },
        {
          "name": "meta.function.static.arrow.js",
          "match": "\\s*+(\\b_?[A-Z][$\\w]*)?(\\.)([_$a-zA-Z][$\\w]*)\\s*+(=)\\s*+(\\basync\\b)?\\s*+([_$a-zA-Z][$\\w]*)\\s*(=\u003e)",
          "captures": {
            "1": {
              "name": "entity.name.class.js"
            },
            "2": {
              "name": "keyword.operator.accessor.js"
            },
            "3": {
              "name": "entity.name.function.js"
            },
            "4": {
              "name": "keyword.operator.assignment.js"
            },
            "5": {
              "name": "storage.type.js"
            },
            "6": {
              "name": "variable.other.readwrite.js"
            },
            "7": {
              "name": "storage.type.function.arrow.js"
            }
          }
        }
      ]
    },
    "literal-arrow-function-labels": {
      "patterns": [
        {
          "name": "meta.function.json.arrow.js",
          "end": "\\s*(=\u003e)",
          "patterns": [
            {
              "include": "#flowtype"
            }
          ],
          "beginCaptures": {
            "1": {
              "name": "entity.name.function.js"
            },
            "2": {
              "name": "punctuation.separator.key-value.js"
            },
            "3": {
              "name": "storage.type.js"
            }
          },
          "endCaptures": {
            "1": {
              "name": "storage.type.function.arrow.js"
            }
          }
        },
        {
          "name": "meta.function.json.arrow.js",
          "end": "\\s*(=\u003e)",
          "patterns": [
            {
              "include": "#flowtype-polymorphs"
            },
            {
              "include": "#flowtype-variable"
            }
          ],
          "beginCaptures": {
            "1": {
              "name": "entity.name.function.js"
            },
            "2": {
              "name": "punctuation.separator.key-value.js"
            },
            "3": {
              "name": "storage.type.js"
            }
          },
          "endCaptures": {
            "1": {
              "name": "storage.type.function.arrow.js"
            }
          }
        },
        {
          "name": "meta.function.json.arrow.js",
          "end": "\\s*(=\u003e)",
          "patterns": [
            {
              "include": "#flowtype"
            }
          ],
          "beginCaptures": {
            "1": {
              "name": "string.quoted.js"
            },
            "2": {
              "name": "punctuation.definition.string.begin.js"
            },
            "3": {
              "name": "entity.name.function.js"
            },
            "4": {
              "name": "punctuation.definition.string.end.js"
            },
            "5": {
              "name": "punctuation.separator.key-value.js"
            },
            "6": {
              "name": "storage.type.js"
            }
          },
          "endCaptures": {
            "1": {
              "name": "storage.type.function.arrow.js"
            }
          },
          "applyEndPatternLast": true
        },
        {
          "name": "meta.function.json.arrow.js",
          "end": "\\s*(=\u003e)",
          "patterns": [
            {
              "include": "#flowtype-polymorphs"
            },
            {
              "include": "#flowtype-variable"
            }
          ],
          "beginCaptures": {
            "1": {
              "name": "string.quoted.js"
            },
            "2": {
              "name": "punctuation.definition.string.begin.js"
            },
            "3": {
              "name": "entity.name.function.js"
            },
            "4": {
              "name": "punctuation.definition.string.end.js"
            },
            "5": {
              "name": "punctuation.separator.key-value.js"
            },
            "6": {
              "name": "storage.type.js"
            }
          },
          "endCaptures": {
            "1": {
              "name": "storage.type.function.arrow.js"
            }
          }
        }
      ]
    },
    "literal-class": {
      "patterns": [
        {
          "begin": "\\s*+(?\u003c!\\.)\\b(class)\\s+",
          "end": "\\s*(?\u003c=})",
          "patterns": [
            {
              "match": "\\s*+\\b(extends)\\b\\s*+",
              "captures": {
                "0": {
                  "name": "meta.class.extends.js"
                },
                "1": {
                  "name": "storage.type.extends.js"
                }
              }
            },
            {
              "name": "entity.name.class.js",
              "match": "(?\u003c!\\.)\\s*+([$_\\p{L}](?:[$\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}])*+)"
            },
            {
              "include": "#flowtype-polymorphs"
            },
            {
              "contentName": "meta.class.body.js",
              "begin": "\\s*+{",
              "end": "\\s*(})",
              "patterns": [
                {
                  "include": "#class-body"
                }
              ],
              "beginCaptures": {
                "0": {
                  "name": "punctuation.section.class.begin.js"
                }
              },
              "endCaptures": {
                "1": {
                  "name": "punctuation.section.class.end.js"
                }
              }
            },
            {
              "include": "#expression"
            }
          ],
          "beginCaptures": {
            "0": {
              "name": "meta.class.js"
            },
            "1": {
              "name": "storage.type.class.js"
            }
          }
        }
      ]
    },
    "literal-comma": {
      "patterns": [
        {
          "name": "meta.delimiter.comma.js",
          "match": "\\s*+,"
        }
      ]
    },
    "literal-constructor": {
      "patterns": [
        {
          "name": "meta.instance.constructor",
          "begin": "\\s*+(new)\\s+(?=[_$a-zA-Z][$\\w.]*)",
          "end": "(?![_$a-zA-Z][$\\w.]*)",
          "patterns": [
            {
              "include": "#support"
            },
            {
              "match": "([_$a-zA-Z][$\\w.]*\\.)?([_$a-zA-Z][$\\w]*)",
              "captures": {
                "2": {
                  "name": "entity.name.type.new.js"
                }
              }
            }
          ],
          "beginCaptures": {
            "1": {
              "name": "keyword.operator.new.js"
            }
          },
          "disabled": true
        }
      ]
    },
    "literal-for": {
      "patterns": [
        {
          "name": "meta.for.js",
          "begin": "\\s*+(?\u003c!\\.)\\b(for)\\b",
          "end": "\\s*\\)",
          "patterns": [
            {
              "begin": "\\s*+\\(",
              "end": "\\s*(?=\\))",
              "patterns": [
                {
                  "include": "#literal-keyword-storage"
                },
                {
                  "include": "#expression"
                },
                {
                  "include": "#literal-punctuation"
                }
              ],
              "beginCaptures": {
                "0": {
                  "name": "meta.brace.round.js"
                }
              }
            }
          ],
          "beginCaptures": {
            "1": {
              "name": "keyword.control.loop.js"
            }
          },
          "endCaptures": {
            "0": {
              "name": "meta.brace.round.js"
            }
          }
        }
      ]
    },
    "literal-function": {
      "patterns": [
        {
          "name": "meta.function.js",
          "begin": "\\s*+(?:\\b(async)\\b\\s+)?\\s*+(?:(?\u003c=\\.\\.\\.)|(?\u003c!\\.))(\\bfunction\\b)\\s*+(\\*?)\\s*+([_$a-zA-Z][$\\w]*)?\\s*+(?=\\(|\u003c)",
          "end": "\\s*(?=\\;|{|\\b(if|switch|try|var|let|const|static|function|return|class|do|for|while|debugger|export|import|yield|type|declare|interface)\\b|\\)|})",
          "patterns": [
            {
              "include": "#flowtype"
            }
          ],
          "beginCaptures": {
            "1": {
              "name": "storage.type.js"
            },
            "2": {
              "name": "storage.type.function.js"
            },
            "3": {
              "name": "keyword.generator.asterisk.js"
            },
            "4": {
              "name": "entity.name.function.js"
            }
          },
          "applyEndPatternLast": true
        },
        {
          "name": "meta.function.js",
          "begin": "\\s*+(\\b[_$a-zA-Z][$\\w]*)\\s*+(=)\\s*+(?:(async)\\s+)?\\s*+((?\u003c!\\.)\\bfunction\\b)\\s*+(\\*?)\\s*+([_$a-zA-Z][$\\w]*)?\\s*+(?=\\(|\u003c)",
          "end": "\\s*(?=\\;|{|\\b(if|switch|try|var|let|const|static|function|return|class|do|for|while|debugger|export|import|yield|type|declare|interface)\\b|\\)|})",
          "patterns": [
            {
              "include": "#flowtype"
            }
          ],
          "beginCaptures": {
            "1": {
              "name": "entity.name.function.js"
            },
            "2": {
              "name": "keyword.operator.assignment.js"
            },
            "3": {
              "name": "storage.type.js"
            },
            "4": {
              "name": "storage.type.function.js"
            },
            "5": {
              "name": "keyword.generator.asterisk.js"
            },
            "6": {
              "name": "entity.name.function.js"
            }
          },
          "applyEndPatternLast": true
        },
        {
          "name": "meta.prototype.function.js",
          "begin": "\\s*+(\\b_?[A-Z][$\\w]*)?(\\.)(prototype)(\\.)([_$a-zA-Z][$\\w]*)\\s*+(=)\\s*+(?:(async)\\s+)?\\s*+((?\u003c!\\.)\\bfunction\\b)\\s*+(\\*?)\\s*+([_$a-zA-Z][$\\w]*)?\\s*+(?=\\(|\u003c)",
          "end": "\\s*(?=\\;|{|\\b(if|switch|try|var|let|const|static|function|return|class|do|for|while|debugger|export|import|yield|type|declare|interface)\\b|\\)|})",
          "patterns": [
            {
              "include": "#flowtype"
            }
          ],
          "beginCaptures": {
            "1": {
              "name": "entity.name.class.js"
            },
            "10": {
              "name": "entity.name.function.js"
            },
            "2": {
              "name": "keyword.operator.accessor.js"
            },
            "3": {
              "name": "variable.language.prototype.js"
            },
            "4": {
              "name": "keyword.operator.accessor.js"
            },
            "5": {
              "name": "entity.name.function.js"
            },
            "6": {
              "name": "keyword.operator.assignment.js"
            },
            "7": {
              "name": "storage.type.js"
            },
            "8": {
              "name": "storage.type.function.js"
            },
            "9": {
              "name": "keyword.generator.asterisk.js"
            }
          },
          "applyEndPatternLast": true
        },
        {
          "name": "meta.function.static.js",
          "begin": "\\s*+(\\b_?[A-Z][$\\w]*)?(\\.)([_$a-zA-Z][$\\w]*)\\s*+(=)\\s*+(?:(async)\\s+)?\\s*+((?\u003c!\\.)\\bfunction\\b)\\s*+(\\*?)\\s*+([_$a-zA-Z][$\\w]*)?\\s*+(?=\\(|\u003c)",
          "end": "\\s*(?=\\;|{|\\b(if|switch|try|var|let|const|static|function|return|class|do|for|while|debugger|export|import|yield|type|declare|interface)\\b|\\)|})",
          "patterns": [
            {
              "include": "#flowtype"
            }
          ],
          "beginCaptures": {
            "1": {
              "name": "entity.name.class.js"
            },
            "2": {
              "name": "keyword.operator.accessor.js"
            },
            "3": {
              "name": "entity.name.function.js"
            },
            "4": {
              "name": "keyword.operator.assignment.js"
            },
            "5": {
              "name": "storage.type.js"
            },
            "6": {
              "name": "storage.type.function.js"
            },
            "7": {
              "name": "keyword.generator.asterisk.js"
            },
            "8": {
              "name": "entity.name.function.js"
            }
          },
          "applyEndPatternLast": true
        }
      ]
    },
    "literal-function-call": {
      "patterns": [
        {
          "include": "#literal-keywords"
        },
        {
          "name": "meta.function-call.without-arguments.js",
          "match": "\\s*+((\\bnew\\b)*)\\s*+([_$a-zA-Z][$\\w]*)\\s*+(\\()\\s*+(\\))",
          "captures": {
            "2": {
              "name": "keyword.operator.js"
            },
            "3": {
              "name": "entity.name.function.js"
            },
            "4": {
              "name": "meta.brace.round.js"
            },
            "5": {
              "name": "meta.brace.round.js"
            }
          }
        },
        {
          "name": "meta.function-call.without-arguments.js",
          "begin": "\\s*+((\\bnew\\b)*)\\s*+(?=(\\[(?:(?\u003e[^\\[\\]]+)|\\g\u003c-1\u003e)*\\])\\s*+\\(\\s*+\\))",
          "end": "(?=.)",
          "patterns": [
            {
              "include": "#square-brackets"
            },
            {
              "include": "#round-brackets"
            }
          ],
          "beginCaptures": {
            "2": {
              "name": "keyword.operator.js"
            }
          },
          "applyEndPatternLast": true
        },
        {
          "name": "meta.function-call.with-arguments.js",
          "begin": "\\s*+((\\bnew\\b)*)\\s*+([_$a-zA-Z][$\\w]*)\\s*+(?=\\()",
          "end": "(?=.)",
          "patterns": [
            {
              "include": "#round-brackets"
            }
          ],
          "beginCaptures": {
            "2": {
              "name": "keyword.operator.js"
            },
            "3": {
              "name": "entity.name.function.js"
            }
          },
          "applyEndPatternLast": true
        },
        {
          "name": "meta.function-call.without-arguments.js",
          "begin": "\\s*+((\\bnew\\b)*)\\s*+(?=(\\[(?:(?\u003e[^\\[\\]]+)|\\g\u003c-1\u003e)*\\])\\s*+\\()",
          "end": "(?=.)",
          "patterns": [
            {
              "include": "#square-brackets"
            },
            {
              "include": "#round-brackets"
            }
          ],
          "beginCaptures": {
            "2": {
              "name": "keyword.operator.js"
            }
          },
          "applyEndPatternLast": true
        }
      ]
    },
    "literal-function-labels": {
      "patterns": [
        {
          "name": "meta.function.json.js",
          "begin": "(?\u003c=^|{|,)\\s*+([_$a-zA-Z][$\\w]*)\\s*+(:)\\s*+(?:(async)\\s+)?\\s*+((?\u003c!\\.)\\bfunction\\b)\\s*+(?:(\\*)\\s*)?\\s*(?=\\(|\u003c)",
          "end": "(?=\\{)",
          "patterns": [
            {
              "include": "#flowtype"
            }
          ],
          "beginCaptures": {
            "1": {
              "name": "entity.name.function.js"
            },
            "2": {
              "name": "punctuation.separator.key-value.js"
            },
            "3": {
              "name": "storage.type.js"
            },
            "4": {
              "name": "storage.type.function.js"
            },
            "5": {
              "name": "keyword.generator.asterisk.js"
            }
          },
          "applyEndPatternLast": true
        },
        {
          "name": "meta.function.json.js",
          "end": "(?=\\{)",
          "patterns": [
            {
              "include": "#flowtype"
            }
          ],
          "beginCaptures": {
            "1": {
              "name": "string.quoted.js"
            },
            "2": {
              "name": "punctuation.definition.string.begin.js"
            },
            "3": {
              "name": "entity.name.function.js"
            },
            "4": {
              "name": "punctuation.definition.string.end.js"
            },
            "5": {
              "name": "punctuation.separator.key-value.js"
            },
            "6": {
              "name": "storage.type.js"
            },
            "7": {
              "name": "storage.type.function.js"
            },
            "8": {
              "name": "keyword.generator.asterisk.js"
            }
          },
          "applyEndPatternLast": true
        }
      ]
    },
    "literal-keyword-storage": {
      "patterns": [
        {
          "begin": "\\s*+(?\u003c!\\.)\\b(const|let|var)\\b",
          "end": "\\s*(?=\\;|\\b(if|switch|try|var|let|const|static|function|return|class|do|for|while|debugger|export|import|yield|type|declare|interface)\\b|\\)|})",
          "patterns": [
            {
              "begin": "\\s*",
              "end": "\\s*((,)|(?=(\\;)|\\b(if|switch|try|var|let|const|static|function|return|class|do|for|while|debugger|export|import|yield|type|declare|interface)\\b|\\)|}))",
              "patterns": [
                {
                  "include": "#flowtype-variable"
                }
              ],
              "endCaptures": {
                "2": {
                  "name": "punctuation.terminator.statement.js"
                }
              }
            }
          ],
          "beginCaptures": {
            "1": {
              "name": "storage.type.js"
            }
          }
        }
      ]
    },
    "literal-keywords": {
      "patterns": [
        {
          "include": "#literal-keyword-storage"
        },
        {
          "name": "keyword.control.flow.js",
          "match": "\\s*+(?\u003c!\\.)\\b(yield)\\b(?:\\s*+(\\*))?",
          "captures": {
            "1": {
              "name": "keyword.control.flow.js"
            },
            "2": {
              "name": "keyword.generator.asterisk.js"
            }
          }
        },
        {
          "name": "keyword.control.flow.js",
          "match": "\\s*+(?\u003c!\\.)\\b(await|return)\\b"
        },
        {
          "name": "keyword.control.conditional.js",
          "match": "\\s*+(?\u003c!\\.)\\b(if|else)\\b"
        },
        {
          "name": "keyword.control.trycatch.js",
          "match": "\\s*+(?\u003c!\\.)\\b(catch|finally|throw|try)\\b"
        },
        {
          "name": "keyword.control.loop.js",
          "match": "\\s*+(?\u003c!\\.)\\b(break|continue|do|goto|while)\\b"
        }
      ]
    },
    "literal-labels": {
      "patterns": [
        {
          "match": "\\s*+(?\u003c!\\.|\\?|\\?\\s|\\?\\s\\s)(((\\\")(\\\\.|[^\\\\\"])*(\\\"))|((')(\\\\.|[^\\\\'])*(')))\\s*+(:)",
          "captures": {
            "1": {
              "name": "constant.other.object.key.js"
            },
            "10": {
              "name": "punctuation.separator.key-value.js"
            },
            "2": {
              "name": "string.quoted.double.js"
            },
            "3": {
              "name": "punctuation.definition.string.begin.js"
            },
            "5": {
              "name": "punctuation.definition.string.end.js"
            },
            "6": {
              "name": "string.quoted.single.js"
            },
            "7": {
              "name": "punctuation.definition.string.begin.js"
            },
            "9": {
              "name": "punctuation.definition.string.end.js"
            }
          }
        },
        {
          "begin": "\\s*+(?\u003c!\\.|\\?|\\?\\s|\\?\\s\\s)(\\[)(?=(?:[^\\[]+)*?\\]\\s*+(:)(?=\\s*+\\S))",
          "end": "\\s*(\\])\\s*+(:)",
          "patterns": [
            {
              "include": "#expression"
            }
          ],
          "beginCaptures": {
            "1": {
              "name": "meta.brace.square.js"
            }
          },
          "endCaptures": {
            "1": {
              "name": "meta.brace.square.js"
            },
            "2": {
              "name": "punctuation.separator.key-value.js"
            }
          }
        },
        {
          "name": "constant.other.object.key.js",
          "match": "\\s*+(?\u003c!\\.|\\?|\\?\\s|\\?\\s\\s)\\s*+([_$a-zA-Z][$\\w]*)\\s*+(:)",
          "captures": {
            "1": {
              "name": "string.unquoted.js"
            },
            "2": {
              "name": "punctuation.separator.key-value.js"
            }
          }
        }
      ]
    },
    "literal-language-constant": {
      "patterns": [
        {
          "name": "constant.language.boolean.true.js",
          "match": "\\s*+(?\u003c!\\.)\\btrue\\b"
        },
        {
          "name": "constant.language.boolean.false.js",
          "match": "\\s*+(?\u003c!\\.)\\bfalse\\b"
        },
        {
          "name": "constant.language.null.js",
          "match": "\\s*+(?\u003c!\\.)\\bnull\\b"
        },
        {
          "name": "constant.language.undefined.js",
          "match": "\\s*+(?\u003c!\\.)\\bundefined\\b"
        },
        {
          "name": "constant.language.nan.js",
          "match": "\\s*+(?\u003c!\\.)\\bNaN\\b"
        }
      ]
    },
    "literal-language-variable": {
      "patterns": [
        {
          "name": "variable.language.arguments.js",
          "match": "\\s*+(?\u003c!(?\u003c!\\.\\.)\\.)\\b(arguments)\\b"
        },
        {
          "name": "variable.language.super.js",
          "match": "\\s*+(?\u003c!(?\u003c!\\.\\.)\\.)\\b(super)\\b\\s*+(?!\\()"
        },
        {
          "name": "variable.language.this.js",
          "match": "\\s*+(?\u003c!(?\u003c!\\.\\.)\\.)\\b(this)\\b"
        },
        {
          "name": "variable.language.self.js",
          "match": "\\s*+(?\u003c!(?\u003c!\\.\\.)\\.)\\b(self)\\b\\s*+(?!\\()"
        },
        {
          "name": "variable.language.proto.js",
          "match": "\\s*+(?\u003c=\\.)\\b(__proto__)\\b"
        },
        {
          "name": "variable.language.constructor.js",
          "match": "\\s*+(?\u003c=\\.)\\b(constructor)\\b\\s*+(?!\\()"
        },
        {
          "name": "variable.language.prototype.js",
          "match": "\\s*+(?\u003c=\\.)\\b(prototype)\\b"
        }
      ]
    },
    "literal-method": {
      "patterns": [
        {
          "name": "meta.function.method.js",
          "begin": "(?\u003c!:)\\s*+(\\bstatic\\b)?\\s*+(\\basync\\b)?\\s*+(\\*?)\\s*+(?\u003c!\\.)([_$a-zA-Z][$\\w]*)\\s*+(?=(\u003c(?:(?\u003e[^\u003c\u003e]+)|\\g\u003c-1\u003e)*\u003e)?(\\())",
          "end": "\\s*(?=.)",
          "patterns": [
            {
              "include": "#flowtype"
            }
          ],
          "beginCaptures": {
            "1": {
              "name": "storage.modifier.js"
            },
            "2": {
              "name": "storage.type.js"
            },
            "3": {
              "name": "keyword.generator.asterisk.js"
            },
            "4": {
              "name": "entity.name.function.method.js"
            }
          },
          "applyEndPatternLast": true
        },
        {
          "name": "meta.function.method.js",
          "end": "\\s*(?=.)",
          "patterns": [
            {
              "include": "#flowtype"
            }
          ],
          "beginCaptures": {
            "1": {
              "name": "storage.modifier.js"
            },
            "2": {
              "name": "storage.type.js"
            },
            "3": {
              "name": "keyword.generator.asterisk.js"
            },
            "4": {
              "name": "entity.name.function.method.js"
            }
          },
          "applyEndPatternLast": true
        },
        {
          "name": "meta.function.method.js",
          "begin": "(?\u003c!:)\\s*+(\\bstatic\\b)?\\s*+(\\basync\\b)?\\s*+(\\*?)\\s*+(?=((\\[(?:(?\u003e[^\\[\\]]+)|\\g\u003c-1\u003e)*\\]))\\s*+(\u003c(?:(?\u003e[^\u003c\u003e]+)|\\g\u003c-1\u003e)*\u003e)?\\s*+(\\())",
          "end": "\\s*(?=.)",
          "patterns": [
            {
              "include": "#flowtype"
            },
            {
              "include": "#square-brackets"
            }
          ],
          "beginCaptures": {
            "1": {
              "name": "storage.modifier.js"
            },
            "2": {
              "name": "storage.type.js"
            },
            "3": {
              "name": "keyword.generator.asterisk.js"
            },
            "4": {
              "name": "entity.name.function.method.js"
            }
          },
          "applyEndPatternLast": true
        },
        {
          "name": "meta.accessor.js",
          "begin": "\\s*+\\b(?:(static)\\s+)?(get|set)\\s+([_$a-zA-Z][$\\w]*)\\s*+(?=\\()",
          "end": "\\s*(?={)",
          "patterns": [
            {
              "include": "#flowtype"
            }
          ],
          "beginCaptures": {
            "1": {
              "name": "storage.modifier.js"
            },
            "2": {
              "name": "storage.type.accessor.js"
            },
            "3": {
              "name": "entity.name.accessor.js"
            }
          },
          "applyEndPatternLast": true
        },
        {
          "name": "meta.accessor.js",
          "begin": "\\s*+\\b(?:(static)\\s+)?(get|set)\\s+(?=((\\[(?:(?\u003e[^\\[\\]]+)|\\g\u003c-1\u003e)*\\])|\\s*+(((')((?:[^']|\\\\')*)('))|\\s*+((\")((?:[^\"]|\\\\\")*)(\"))))\\s*+(\\())",
          "end": "\\s*(?={)",
          "patterns": [
            {
              "include": "#flowtype-parse-array"
            },
            {
              "include": "#literal-string"
            },
            {
              "include": "#flowtype"
            }
          ],
          "beginCaptures": {
            "1": {
              "name": "storage.modifier.js"
            },
            "2": {
              "name": "storage.type.accessor.js"
            },
            "3": {
              "name": "entity.name.accessor.js"
            }
          },
          "applyEndPatternLast": true
        }
      ]
    },
    "literal-method-alternate": {
      "patterns": [
        {
          "name": "meta.function.method.js",
          "end": "\\s*(?=.)",
          "patterns": [
            {
              "include": "#flowtype"
            }
          ],
          "beginCaptures": {
            "1": {
              "name": "storage.modifier.js"
            },
            "2": {
              "name": "storage.type.js"
            },
            "3": {
              "name": "keyword.generator.asterisk.js"
            },
            "5": {
              "name": "entity.name.function.method.js"
            }
          },
          "applyEndPatternLast": true
        }
      ]
    },
    "literal-method-call": {
      "patterns": [
        {
          "name": "meta.function-call.static.without-arguments.js",
          "match": "\\s*+(?:(?\u003c=\\.)|\\b)([A-Z][$\\w]*)\\s*+(\\.)([_$a-zA-Z][$\\w]*)\\s*+(\\(\\s*+\\))",
          "captures": {
            "1": {
              "name": "variable.other.class.js"
            },
            "2": {
              "name": "keyword.operator.accessor.js"
            },
            "3": {
              "name": "entity.name.function.js"
            },
            "4": {
              "name": "meta.group.braces.round.function.arguments.js"
            }
          }
        },
        {
          "name": "meta.function-call.static.with-arguments.js",
          "begin": "\\s*+(?:(?\u003c=\\.)|\\b)\\s*+([A-Z][$\\w]*)\\s*+(\\.)([_$a-zA-Z][$\\w]*)\\s*+(?=\\()",
          "end": "(?=.)",
          "patterns": [
            {
              "include": "#round-brackets"
            }
          ],
          "beginCaptures": {
            "1": {
              "name": "variable.other.class.js"
            },
            "2": {
              "name": "keyword.operator.accessor.js"
            },
            "3": {
              "name": "entity.name.function.js"
            }
          },
          "applyEndPatternLast": true
        },
        {
          "name": "meta.function-call.method.without-arguments.js",
          "match": "\\s*+(?\u003c=\\.)\\s*+([_$a-zA-Z][$\\w]*)\\s*+(\\(\\s*+\\))",
          "captures": {
            "1": {
              "name": "entity.name.function.js"
            },
            "2": {
              "name": "meta.group.braces.round.function.arguments.js"
            }
          }
        },
        {
          "name": "meta.function-call.method.with-arguments.js",
          "begin": "\\s*+(?\u003c=\\.)([_$a-zA-Z][$\\w]*)\\s*+(?=\\()",
          "end": "(?=.)",
          "patterns": [
            {
              "include": "#round-brackets"
            }
          ],
          "beginCaptures": {
            "1": {
              "name": "entity.name.function.js"
            }
          },
          "applyEndPatternLast": true
        }
      ]
    },
    "literal-module": {
      "patterns": [
        {
          "name": "keyword.control.module.js",
          "match": "\\s*+(?\u003c!\\.)\\b(import|export|default)\\b"
        },
        {
          "name": "keyword.control.module.reference.js",
          "match": "\\s*+(?\u003c!\\.)\\b(from|as)\\b"
        }
      ]
    },
    "literal-number": {
      "patterns": [
        {
          "match": "\\s*+((?:\\B[-+])?(?:\\b0[bB][0-1]*|\\b0[oO][0-7]*|\\b0[xX][0-9a-fA-F]*|(\\B\\.[0-9]+|\\b[0-9]+(\\.[0-9]*)?)([eE][-+]?[0-9]+)?))",
          "captures": {
            "1": {
              "name": "constant.numeric.js"
            }
          }
        },
        {
          "match": "\\s*+((?:\\B[-+]|\\b)(Infinity)\\b)",
          "captures": {
            "1": {
              "name": "constant.language.infinity.js"
            }
          }
        }
      ]
    },
    "literal-object": {
      "patterns": [
        {
          "begin": "(?:(?\u003c=\\(|\\[)|(?:\\s*(?:(=)|\\b(default)\\b|\\b(return)\\b|(,))))\\s*({)",
          "end": "\\s*+(})",
          "patterns": [
            {
              "include": "#literal-function-labels"
            },
            {
              "include": "#literal-arrow-function-labels"
            },
            {
              "include": "#literal-arrow-function"
            },
            {
              "include": "#literal-method"
            },
            {
              "include": "#literal-labels"
            },
            {
              "include": "#expression"
            },
            {
              "include": "#literal-punctuation"
            }
          ],
          "beginCaptures": {
            "1": {
              "name": "keyword.operator.assignment.js"
            },
            "2": {
              "name": "keyword.control.module.js"
            },
            "3": {
              "name": "keyword.control.flow.js"
            },
            "4": {
              "name": "meta.delimiter.comma.js"
            },
            "5": {
              "name": "meta.brace.curly.js"
            }
          },
          "endCaptures": {
            "1": {
              "name": "meta.brace.curly.js"
            }
          }
        }
      ]
    },
    "literal-operators": {
      "patterns": [
        {
          "name": "keyword.operator.js",
          "match": "\\s*+(?\u003c!\\.)\\b(delete|in|instanceof|new|of|typeof|void|with)\\b"
        },
        {
          "name": "keyword.operator.logical.js",
          "match": "\\s*+(!(?!=)|\u0026\u0026|\\|\\|)"
        },
        {
          "name": "keyword.operator.assignment.js",
          "match": "\\s*+(=(?!(=|\u003e)))"
        },
        {
          "name": "keyword.operator.assignment.augmented.js",
          "match": "\\s*+(%=|\u0026=|\\*=|\\+=|-=|/=|\\^=|\\|=|\u003c\u003c=|\u003e\u003e=|\u003e\u003e\u003e=)"
        },
        {
          "name": "keyword.operator.bitwise.js",
          "match": "\\s*+(~|\u003c\u003c|\u003e\u003e\u003e|\u003e\u003e|\u0026|\\^|\\|)"
        },
        {
          "name": "keyword.operator.relational.js",
          "match": "\\s*+(\u003c=|\u003e=|\u003c|\u003e)"
        },
        {
          "name": "keyword.operator.comparison.js",
          "match": "\\s*+(===|!==|==|!=)"
        },
        {
          "name": "keyword.operator.arithmetic.js",
          "match": "\\s*+(--|\\+\\+|/(?!/|\\*)|%|\\*(?\u003c!/\\*)|\\+|-)"
        },
        {
          "begin": "\\s*+(\\?)",
          "end": "\\s*(:)",
          "patterns": [
            {
              "include": "#expression"
            }
          ],
          "beginCaptures": {
            "1": {
              "name": "keyword.operator.ternary.js"
            }
          },
          "endCaptures": {
            "1": {
              "name": "keyword.operator.ternary.js"
            }
          }
        },
        {
          "name": "keyword.operator.spread.js",
          "match": "\\s*+(?\u003c!\\.)\\.\\.\\."
        },
        {
          "name": "keyword.operator.accessor.js",
          "match": "\\."
        }
      ]
    },
    "literal-prototype": {
      "patterns": [
        {
          "name": "meta.prototype.access.js",
          "match": "\\s*+([_$a-zA-Z][$\\w]*)(\\.)(prototype)\\b",
          "captures": {
            "1": {
              "name": "entity.name.class.js"
            },
            "2": {
              "name": "keyword.operator.accessor.js"
            },
            "3": {
              "name": "variable.language.prototype.js"
            }
          }
        },
        {
          "name": "meta.prototype.declaration.js",
          "match": "\\s*+([_$a-zA-Z][$\\w]*)(\\.)(prototype)\\s*+=\\s*+",
          "captures": {
            "1": {
              "name": "entity.name.class.js"
            },
            "2": {
              "name": "keyword.operator.accessor.js"
            },
            "3": {
              "name": "variable.language.prototype.js"
            }
          }
        }
      ]
    },
    "literal-punctuation": {
      "patterns": [
        {
          "include": "#literal-semi-colon"
        },
        {
          "include": "#literal-comma"
        }
      ]
    },
    "literal-quasi": {
      "patterns": [
        {
          "name": "string.quasi.js",
          "contentName": "string.quoted.template.js",
          "begin": "\\s*+([a-zA-Z$_][\\w$_]*)?((`))",
          "end": "\\s*(?\u003c!\\\\)((`))",
          "patterns": [
            {
              "name": "entity.quasi.element.js",
              "begin": "(?\u003c!\\\\)\\${",
              "end": "\\s*}",
              "patterns": [
                {
                  "include": "#expression"
                }
              ],
              "beginCaptures": {
                "0": {
                  "name": "punctuation.quasi.element.begin.js"
                }
              },
              "endCaptures": {
                "0": {
                  "name": "punctuation.quasi.element.end.js"
                }
              }
            },
            {
              "include": "#string-content"
            }
          ],
          "beginCaptures": {
            "1": {
              "name": "entity.quasi.tag.name.js"
            },
            "2": {
              "name": "punctuation.definition.quasi.begin.js"
            },
            "3": {
              "name": "string.quoted.template.js"
            }
          },
          "endCaptures": {
            "1": {
              "name": "punctuation.definition.quasi.end.js"
            },
            "2": {
              "name": "string.quoted.template.js"
            }
          }
        }
      ]
    },
    "literal-regexp": {
      "patterns": [
        {
          "name": "string.regexp.js",
          "begin": "(?\u003c=\\.|\\(|,|{|}|\\[|;|,|\u003c|\u003e|\u003c=|\u003e=|==|!=|===|!==|\\+|-|\\*|%|\\+\\+|--|\u003c\u003c|\u003e\u003e|\u003e\u003e\u003e|\u0026|\\||\\^|!|~|\u0026\u0026|\\|\\||\\?|:|=|\\+=|-=|\\*=|%=|\u003c\u003c=|\u003e\u003e=|\u003e\u003e\u003e=|\u0026=|\\|=|\\^=|/|/=|\\Wnew|\\Wdelete|\\Wvoid|\\Wtypeof|\\Winstanceof|\\Win|\\Wdo|\\Wreturn|\\Wcase|\\Wthrow|^new|^delete|^void|^typeof|^instanceof|^in|^do|^return|^case|^throw|^)\\s*+(/)(?!/|\\*|$)",
          "end": "(/)([gimyu]*)",
          "patterns": [
            {
              "include": "source.regexp.babel"
            }
          ],
          "beginCaptures": {
            "1": {
              "name": "punctuation.definition.string.begin.js"
            }
          },
          "endCaptures": {
            "1": {
              "name": "punctuation.definition.string.end.js"
            },
            "2": {
              "name": "keyword.other.js"
            }
          }
        }
      ]
    },
    "literal-semi-colon": {
      "patterns": [
        {
          "name": "punctuation.terminator.statement.js",
          "match": "\\s*+\\;"
        }
      ]
    },
    "literal-string": {
      "patterns": [
        {
          "contentName": "string.quoted.single.js",
          "begin": "\\s*+(('))",
          "end": "\\s*+(?:(('))|(\n))",
          "patterns": [
            {
              "include": "#string-content"
            }
          ],
          "beginCaptures": {
            "1": {
              "name": "string.quoted.single.js"
            },
            "2": {
              "name": "punctuation.definition.string.begin.js"
            }
          },
          "endCaptures": {
            "1": {
              "name": "string.quoted.single.js"
            },
            "2": {
              "name": "punctuation.definition.string.end.js"
            },
            "3": {
              "name": "invalid.illegal.newline.js"
            }
          }
        },
        {
          "contentName": "string.quoted.double.js",
          "begin": "\\s*+((\"))",
          "end": "\\s*+(?:((\"))|(\n))",
          "patterns": [
            {
              "include": "#string-content"
            }
          ],
          "beginCaptures": {
            "1": {
              "name": "string.quoted.double.js"
            },
            "2": {
              "name": "punctuation.definition.string.begin.js"
            }
          },
          "endCaptures": {
            "1": {
              "name": "string.quoted.double.js"
            },
            "2": {
              "name": "punctuation.definition.string.end.js"
            },
            "3": {
              "name": "invalid.illegal.newline.js"
            }
          }
        }
      ]
    },
    "literal-switch": {
      "patterns": [
        {
          "name": "meta.switch.js",
          "begin": "\\s*+(?\u003c!\\.)\\b(switch)\\b",
          "end": "\\s*\\}",
          "patterns": [
            {
              "include": "#round-brackets"
            },
            {
              "begin": "\\s*+\\{",
              "end": "\\s*(?=})",
              "patterns": [
                {
                  "begin": "\\s*+(?\u003c!\\.)\\b(case|default)\\b",
                  "end": "\\s*(:)",
                  "patterns": [
                    {
                      "include": "#expression"
                    }
                  ],
                  "beginCaptures": {
                    "1": {
                      "name": "keyword.control.switch.js"
                    }
                  },
                  "endCaptures": {
                    "1": {
                      "name": "keyword.operator.js"
                    }
                  }
                },
                {
                  "include": "$self"
                }
              ],
              "beginCaptures": {
                "0": {
                  "name": "meta.brace.curly.js"
                }
              }
            }
          ],
          "beginCaptures": {
            "1": {
              "name": "keyword.control.switch.js"
            }
          },
          "endCaptures": {
            "0": {
              "name": "meta.brace.curly.js"
            }
          }
        }
      ]
    },
    "literal-variable": {
      "patterns": [
        {
          "name": "variable.other.constant.js",
          "match": "\\s*+[A-Z][_$\\dA-Z]*\\b"
        },
        {
          "name": "variable.other.dollar.js",
          "match": "\\s*+\\$[$\\w]*"
        },
        {
          "name": "meta.property.class.js",
          "match": "\\s*+\\b([A-Z][$\\w]*)\\s*+(\\.)([_$a-zA-Z][$\\w]*)",
          "captures": {
            "1": {
              "name": "variable.other.class.js"
            },
            "2": {
              "name": "keyword.operator.accessor.js"
            },
            "3": {
              "name": "variable.other.property.static.js"
            }
          }
        },
        {
          "name": "variable.other.object.js",
          "match": "\\s*+(?\u003c!\\.)[_$a-zA-Z][$\\w]*\\s*+(?=[\\[\\.])",
          "captures": {
            "1": {
              "name": "variable.other.object.js"
            }
          }
        },
        {
          "name": "meta.property.object.js",
          "match": "\\s*+(?\u003c=\\.)\\s*+[_$a-zA-Z][$\\w]*",
          "captures": {
            "0": {
              "name": "variable.other.property.js"
            }
          }
        },
        {
          "name": "variable.other.readwrite.js",
          "match": "\\s*+[_$a-zA-Z][$\\w]*"
        }
      ]
    },
    "miscellaneous": {
      "patterns": [
        {
          "match": "\\s*(=\u003e)",
          "captures": {
            "1": {
              "name": "storage.type.function.arrow.js"
            }
          }
        }
      ]
    },
    "round-brackets": {
      "patterns": [
        {
          "end": "\\s*\\)",
          "patterns": [
            {
              "include": "#flowtype-typecast"
            },
            {
              "include": "#expression"
            }
          ],
          "beginCaptures": {
            "2": {
              "name": "meta.brace.round.js"
            }
          },
          "endCaptures": {
            "0": {
              "name": "meta.brace.round.js"
            }
          }
        },
        {
          "begin": "\\s*+\\(",
          "end": "\\s*\\)",
          "patterns": [
            {
              "include": "#expression"
            }
          ],
          "beginCaptures": {
            "0": {
              "name": "meta.brace.round.js"
            }
          },
          "endCaptures": {
            "0": {
              "name": "meta.brace.round.js"
            }
          }
        }
      ]
    },
    "special-comments-conditional-compilation": {
      "patterns": [
        {
          "name": "comment.block.conditional.js",
          "begin": "\\s*+/\\*(?=@)",
          "end": "\\s*\\*/",
          "patterns": [
            {
              "name": "punctuation.definition.comment.js",
              "match": "\\s*+/\\*"
            },
            {
              "include": "$self"
            }
          ],
          "captures": {
            "0": {
              "name": "punctuation.definition.comment.js"
            }
          },
          "endCaptures": {
            "1": {
              "name": "keyword.control.conditional.js"
            },
            "2": {
              "name": "punctuation.definition.keyword.js"
            }
          }
        },
        {
          "name": "keyword.control.conditional.js",
          "match": "\\s*+(?!@)(@)(if|elif|else|end|ifdef|endif|cc_on|set)\\b",
          "captures": {
            "1": {
              "name": "punctuation.definition.keyword.js"
            }
          }
        },
        {
          "name": "variable.other.conditional.js",
          "match": "\\s*+(?!@)(@)(_win32|_win16|_mac|_alpha|_x86|_mc680x0|_PowerPC|_jscript|_jscript_build|_jscript_version|_debug|_fast|[a-zA-Z]\\w+)",
          "captures": {
            "1": {
              "name": "punctuation.definition.variable.js"
            }
          }
        }
      ]
    },
    "square-brackets": {
      "patterns": [
        {
          "begin": "\\s*+\\[",
          "end": "\\s*\\]",
          "patterns": [
            {
              "include": "#expression"
            }
          ],
          "beginCaptures": {
            "0": {
              "name": "meta.brace.square.js"
            }
          },
          "endCaptures": {
            "0": {
              "name": "meta.brace.square.js"
            }
          }
        }
      ]
    },
    "string-content": {
      "patterns": [
        {
          "name": "constant.character.escape.newline.js",
          "match": "\\\\\n"
        },
        {
          "name": "constant.character.escape",
          "match": "\\\\['|\"|\\\\|n|r|t|b|f|v|0]"
        },
        {
          "name": "constant.character.escape",
          "match": "\\\\u((\\{[0-9a-fA-F]+\\})|[0-9a-fA-F]{4})"
        },
        {
          "name": "constant.character.escape",
          "match": "\\\\x[0-9a-fA-F]{2}"
        }
      ]
    },
    "support": {
      "patterns": [
        {
          "name": "support.class.builtin.js",
          "match": "\\s*+\\b(Array|ArrayBuffer|Boolean|DataView|Date|Float(32|64)Array|Int(8|16|32)Array|Function|GeneratorFunction|Map|Math|Number|Object|Promise|Proxy|RegExp|Set|String|Uint(8|16|32)Array|Uint8ClampedArray|WeakMap|WeakSet)\\b"
        },
        {
          "name": "support.function.js",
          "match": "\\s*+(?\u003c!\\.)\\b(decodeURI|decodeURIComponent|encodeURI|encodeURIComponent|escape|eval|isFinite|isNaN|parseFloat|parseInt|unescape)\\b"
        },
        {
          "name": "support.function.mutator.js",
          "match": "(?\u003c=\\.)(shift|sort|splice|unshift|pop|push|reverse)\\b"
        },
        {
          "name": "support.class.error.js",
          "match": "\\s*+(?\u003c!\\.)\\b((Eval|Range|Reference|Syntax|Type|URI)?Error)\\b"
        },
        {
          "name": "keyword.other.js",
          "match": "\\s*+(?\u003c!\\.)\\b(debugger)\\b"
        },
        {
          "name": "support.type.object.dom.js",
          "match": "\\s*+(?\u003c!\\.)\\b(document|window)\\b"
        },
        {
          "name": "support.constant.dom.js",
          "match": "\\s*+\\b(ELEMENT_NODE|ATTRIBUTE_NODE|TEXT_NODE|CDATA_SECTION_NODE|ENTITY_REFERENCE_NODE|ENTITY_NODE|PROCESSING_INSTRUCTION_NODE|COMMENT_NODE|DOCUMENT_NODE|DOCUMENT_TYPE_NODE|DOCUMENT_FRAGMENT_NODE|NOTATION_NODE|INDEX_SIZE_ERR|DOMSTRING_SIZE_ERR|HIERARCHY_REQUEST_ERR|WRONG_DOCUMENT_ERR|INVALID_CHARACTER_ERR|NO_DATA_ALLOWED_ERR|NO_MODIFICATION_ALLOWED_ERR|NOT_FOUND_ERR|NOT_SUPPORTED_ERR|INUSE_ATTRIBUTE_ERR)\\b"
        },
        {
          "match": "\\s*+(?\u003c!\\.)\\b(console)(?:(\\.)(warn|info|log|error|time|timeEnd|assert))?\\b",
          "captures": {
            "1": {
              "name": "support.type.object.console.js"
            },
            "2": {
              "name": "keyword.operator.accessor.js"
            },
            "3": {
              "name": "support.function.console.js"
            }
          }
        },
        {
          "match": "\\s*+(?\u003c!\\.)\\b(process)(?:(\\.)(stdout|stderr|stdin|argv|execPath|execArgv|env|exitCode|version|versions|config|pid|title|arch|platform|mainModule))?\\b",
          "captures": {
            "1": {
              "name": "support.type.object.process.js"
            },
            "2": {
              "name": "keyword.operator.accessor.js"
            },
            "3": {
              "name": "support.type.object.process.js"
            }
          }
        },
        {
          "match": "\\s*+(?\u003c!\\.)\\b(process)(?:(\\.)(abort|chdir|cwd|exit|getgid|setgid|getuid|setuid|setgroups|getgroups|initgroups|kill|memoryUsage|nextTick|umask|uptime|hrtime))?\\b",
          "captures": {
            "1": {
              "name": "support.type.object.process.js"
            },
            "2": {
              "name": "keyword.operator.accessor.js"
            },
            "3": {
              "name": "support.function.process.js"
            }
          }
        },
        {
          "match": "\\s*+\\b(((?\u003c!\\.)module\\.((?\u003c!\\,)exports|id|require|parent|filename|loaded|children)|exports))\\b",
          "captures": {
            "1": {
              "name": "support.type.object.module.js"
            },
            "2": {
              "name": "keyword.operator.accessor.js"
            },
            "3": {
              "name": "support.type.object.module.js"
            }
          }
        },
        {
          "name": "support.type.object.node.js",
          "match": "\\s*+(?\u003c!\\.)\\b(global|GLOBAL|root|__dirname|__filename)\\b"
        },
        {
          "name": "support.class.node.js",
          "match": "\\s*+\\b(Buffer|EventEmitter|Server|Pipe|Socket|REPLServer|ReadStream|WriteStream|Stream|Inflate|Deflate|InflateRaw|DeflateRaw|GZip|GUnzip|Unzip|Zip)\\b"
        },
        {
          "name": "meta.tag.mustache.js",
          "begin": "\\s*+{{",
          "end": "\\s*}}"
        }
      ]
    }
  }
}
